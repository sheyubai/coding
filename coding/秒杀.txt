# A. 请求入队主链路（Controller 流）

> 思想：**入口不落库，只做“拦截→校验→入队→立即返回”**，把高并发挤到消息里慢慢消化。

1. **入口与网关**

- Nginx → API Gateway：鉴权、验签、黑白名单、限流/熔断、灰度路由等。
- 通过后将请求打上 `traceId`。

1. **Controller（不直连 MySQL）**
    只做轻量逻辑：

- **幂等号**：生成/校验（如 `idempotentKey = hash(userId,bizId,params)`，也可从 header/uuid 获取），在 Redis 里 `SETNX` 防重复提交（TTL）。
- **参数校验**、用户态校验（登录、权限）。
- **风控/限流**（用户频控、IP 频控、业务维度限流）。
- **入队削峰**：
  - 先丢到 Redis（例如 List/Stream）作为垫片缓冲；按“**100 条一批**”打批次标签。
  - 再投到 MQ（如 `order.create` 主题）。
- **结果占位**：在 Redis 写入 `resultKey -> IN_PROGRESS`（设置 TTL），用于前端轮询/长连接通知。
- **立刻返回**：HTTP 只返回“已受理 + resultKey/traceId”，**不做 DB 操作**。

1. **前端结果获取（图左下两块）**

- **正常**：WebSocket/长轮询按 `resultKey` 订阅结果消息；
- **异常兜底**：若入口就失败，按“前端错误逻辑”提示错误码；若长时间无结果，展示“处理中/稍后刷新”。

------

# B. 业务消费与落库链路（消费逻辑 + 表操作逻辑）

> 思想：**消费者批量处理、强幂等、分布式锁、防重复、可重试，失败入库 + Job 补偿**。

1. **取数与分批**

- 消费者从 Redis/MQ 拉取消息；按图中的设计“**每 100 条为一批**”处理：
  - 有助于**批量 SQL**（单批一次事务），提升吞吐、降低锁冲突。
  - 同一分区/同一主键维度做**保序**（例如按 `userId` 或 `skuId` 分区）。

1. **幂等与并发控制**

- **消息幂等**：幂等表或 Redis Set 记录 `msgId/idempotentKey`；重复消费直接 ACK/跳过。
- **业务幂等**：数据库层**唯一键**/去重约束（如 `(bizId, userId)` 唯一）。
- **分布式锁**：对同一业务键（如同一订单/同一 SKU）上锁，避免并发写撞车。

1. **业务处理（表操作逻辑）**

- Service → Mapper：开启**本地事务**，对批次做**批量 INSERT/UPDATE**：
  - 例如：创建订单、扣减库存、写资金/积分流水等。
  - 读写分离下：**主库写**，从库只做查询（延迟一致性要注意）。
- **二次事件**：对“库存变更/订单状态变更”等**再发 MQ**（供缓存回写、ES 索引、下游系统订阅）。
- **结果回写**：把每条消息的处理结果写回 `resultKey -> SUCCESS/FAIL + reason`，并产出**结果主题**推给前端通道。

1. **失败与重试（图中“失败消费”）**

- **可重试异常**（网络抖动、锁冲突）：**指数退避**重试 N 次；超过阈值 → **DLQ(死信队列)/失败表**。
- **不可重试**（参数错、幂等冲突）：**直接失败**记录原因（业务可见）。
- **下游不可用**：入失败队列，等待恢复后**Job 扫描补偿**。
- **ACK 策略**：成功即 ACK；失败按上面策略要么重投要么入库。

1. **超时消费逻辑（图右侧）**

- 定时任务扫描超时未完成的单据/`resultKey`：
  - 订单类：关闭订单、回滚库存；
  - 发“取消/回滚”事件；
  - 前端拿到“超时/已关闭”状态。

------

# C. Binlog 回补链路（Canal 逻辑）

> 思想：**以数据库事实为准**，通过 binlog 增量流把读模型/缓存同步好，并对主链路遗漏做“最终一致性补偿”。

1. **订阅与解析**

- MySQL 主库写入后产出 **binlog** → **Canal Server** 订阅 → **Canal Client** 解析成结构化变更事件（表、主键、变更前后值、事务序号等）。

1. **投递与统一消费**

- Canal Client 把变更事件投到 MQ（如 `db.change`/`inventory.changed` 主题）。
- 统一消费者做三件事：
  - **读模型同步**：更新缓存（Redis）、搜索引擎（ES）、统计表等。
  - **补偿修复**：若主链路因为异常**没来得及回写缓存/下游**，以 binlog 为“最终事实”**回填**；必要时**补发结果消息**。
  - **顺序与幂等**：按 `(table, pk)` 做**分区保序**；以 `txId + table + pk + op` 做幂等，保证同一主键变更不乱序、不重复。

1. **对账与监控**

- 关键指标：**入口入队数 vs. 成功消费数 vs. binlog 变更数**；
- 若 Canal 流量落后（延迟高）或丢失，**告警**并启动重放/补偿。

------

## 你在实现时可以直接复用的关键“卡口”

- **幂等键**：`idempotentKey = hash(userId, bizId, payload)`，入口 `SETNX` + 消费端幂等表双保险。
- **批处理**：消息打批（100 条），DB 批量写（JDBC 批处理/批量 SQL）。
- **分布式锁**：针对热点键（如 `sku:123`）避免并发扣减乱序。
- **失败表 + DLQ + XXL-Job**：全链路可观测、可修复。
- **结果通道**：`resultKey` + WebSocket/轮询，把“异步处理”换成“准实时可见结果”。
- **Canal 最终一致性**：把“写库事实”扩散到缓存/ES/下游，兜住“消息丢失/回写失败”的长尾。

这样三条流就形成闭环：
 **入口削峰入队 → 批量幂等落库 → binlog 驱动的最终一致性回补**，再配合**失败重试/超时关单/结果回写**，即可在高并发下保证“性能 + 正确性 + 可观测性”。